#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <tesseract/baseapi.h>
#include <fstream>
#include <png.h>
#include <iostream>
#include <leptonica/allheaders.h>
#include <string>
#include <vector>


class Coordinates {
    public: 
        int x1;
        int x2;
        int y1;
        int y2;

        Coordinates(int x1, int x2, int y1, int y2) : x1(x1), x2(x2), y1(x1), y2(y2) {}
};

class RecognizedWord {
    public: 
        Coordinates position;
        const char* word;
        float confidence;

        RecognizedWord(const char* word, float confidence, int x1, int x2, int y1, int y2)
            : word(word), confidence(confidence), position(x1,x2,y1,y2){}
};

class DetectedWords {
    public:
        std::vector<int> selectedWordIds;
        std::vector<RecognizedWord> recognizedWords;
    // DetectedWords()

    void AddWord(const char* word, float confidence, int x1, int x2, int y1, int y2) {
        recognizedWords.push_back(RecognizedWord(word, confidence, x1, x2, y1, y2));
    }

};



void saveXImageAsPNG(XImage* ximage, const std::string& filename) {
    int width = ximage->width;
    int height = ximage->height;
    int depth = ximage->depth;
    int bytes_per_line = ximage->bytes_per_line;
    unsigned char* image_data = reinterpret_cast<unsigned char*>(ximage->data);

    FILE* fp = fopen(filename.c_str(), "wb");
    if (!fp) {
        std::cerr << "Failed to open file for writing: " << filename << std::endl;
        return;
    }

    png_structp png = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
    if (!png) {
        fclose(fp);
        std::cerr << "Failed to create PNG write struct" << std::endl;
        return;
    }

    png_infop info = png_create_info_struct(png);
    if (!info) {
        fclose(fp);
        png_destroy_write_struct(&png, NULL);
        std::cerr << "Failed to create PNG info struct" << std::endl;
        return;
    }

    png_init_io(png, fp);
    png_set_IHDR(png, info, width, height, 8, PNG_COLOR_TYPE_RGB, PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);
    png_write_info(png, info);

    png_bytep row = new png_byte[bytes_per_line];

    for (int y = 0; y < height; ++y) {
        for (int x = 0; x < width; ++x) {
            row[x * 3] = image_data[y * bytes_per_line + x * depth / 8 + 2];     // Red
            row[x * 3 + 1] = image_data[y * bytes_per_line + x * depth / 8 + 1]; // Green
            row[x * 3 + 2] = image_data[y * bytes_per_line + x * depth / 8];     // Blue
        }
        png_write_row(png, row);
    }

    delete[] row;

    png_write_end(png, info);
    png_destroy_write_struct(&png, &info);
    fclose(fp);

    std::cout << "XImage saved as PNG: " << filename << std::endl;
}

void savePixToFile(Pix* pix, const std::string& filename) {
    if (!pix) {
        std::cerr << "Invalid Pix* image." << std::endl;
        return;
    }

    if (filename.empty()) {
        std::cerr << "Invalid filename." << std::endl;
        return;
    }

    // Save the Pix* image to file
    if (pixWrite(filename.c_str(), pix, IFF_PNG) != 0) {
        std::cerr << "Failed to save the image to file: " << filename << std::endl;
        return;
    }

    std::cout << "Image saved to file: " << filename << std::endl;
}

Pix* ximageToPix(XImage* ximage) {
    int width = ximage->width;
    int height = ximage->height;
    int depth = ximage->bits_per_pixel;
    int bytes_per_line = ximage->bytes_per_line;

    // Create a new Pix* structure
    Pix* pix = pixCreate(width, height, depth);

    // Copy the pixel data from ximage to pix
    unsigned char* src_data = reinterpret_cast<unsigned char*>(ximage->data);

    l_uint32* dest_data = reinterpret_cast<l_uint32*>(pixGetData(pix));

    for (int y = 0; y < height; ++y) {
        unsigned char* src_line = src_data + y * bytes_per_line;
        l_uint32* dest_line = dest_data + y * pixGetWpl(pix);
        // std::cout<<dest_line << (y * pixGetWpl(pix))<<std::endl;
        // Copy each pixel from src_line to dest_line
        for (int x = 0; x < width; ++x) {
            dest_line[x] = static_cast<l_uint32>(src_line[x]);
        }
    }
    return pix;
}

Pix* takeScreenshot() {
    Display* display = XOpenDisplay(NULL);
    Window root = DefaultRootWindow(display);
    XWindowAttributes windowAttributes;
    XGetWindowAttributes(display, root, &windowAttributes);
    int width = windowAttributes.width;
    int height = windowAttributes.height;
    XImage* image = XGetImage(display, root, 0, 0, width, height, AllPlanes, ZPixmap);
    std::cout<<"Size: "<<sizeof(image->data)<<std::endl;
    saveXImageAsPNG(image, "dupa.png");
    const char *filename = "dupa.png";
    Pix* buffer = pixRead(filename);
    std::cout<<"Size: "<<sizeof(pixGetData(buffer))<<std::endl;
    return buffer;
}

int main() {

    Pix* pix = takeScreenshot();

    l_uint32 pixel;
    int x = 1;  // X-coordinate of the pixel
    int y = 1;  // Y-coordinate of the pixel

    if (pix!=NULL) {
    // The pix image is valid
    
        std::cout<<"yes" <<std::endl;
    // You can proceed with pixel access and other operations
    // ...
} else {
    // The pix image is invalid
    // Handle the error case or return
        std::cout<<"nooooooo" <<std::endl;
    // ...
}
    
    if (pixGetPixel(pix, x, y, &pixel)) {
        // The pixel value is stored in 'pixel'
        // You can perform operations or access its components
        // For example, you can get the red, green, blue components using the following masks:
        int red = GET_DATA_BYTE(&pixel, COLOR_RED);
        int green = GET_DATA_BYTE(&pixel, COLOR_GREEN);
        int blue = GET_DATA_BYTE(&pixel, COLOR_BLUE);
        std::cout << red << "   " << green << "    " << blue << "  pixold"<<std::endl;
        // Do something with the pixel values
        // ...
    } else {
        std::cout<<"fuccckkk" <<std::endl;
        // Failed to get the pixel value
        // Handle the error case
    }



    Pix* pixGray = pixConvertRGBToGray(pix, 0.21, 0.72, 0.07);
    savePixToFile(pix, "output.png");
    // cv::cvtColor(screenshot, screenshot, cv::COLOR_BGR2GRAY);
    // const unsigned char* image = reinterpret_cast<const unsigned char*>(screenshot.data);
    // std::memcpy(const_cast<unsigned char*>(image), screenshot.data, screenshot.total());
    // std::ofstream outfile("output.txt");
    // std::streambuf* coutbuf = std::cout.rdbuf();
    tesseract::TessBaseAPI api;

    api.Init(NULL, "eng", tesseract::OEM_DEFAULT);
    api.SetPageSegMode(tesseract::PSM_AUTO);

    // // Set the image
    api.SetImage(pix);
    char* recognizedText = api.GetUTF8Text();
    
    // // Process the recognized text
    std::cout << "Recognized text: " << recognizedText << std::endl;
    // // cv::Mat imageMat(screenshot.rows, screenshot.cols, CV_8UC1, const_cast<unsigned char*>(image));
    // // cv::imshow("Gowno", imageMat);
    // // Get the recognized words and their bounding boxes
    tesseract::ResultIterator* iter = api.GetIterator();
    std::cout << "Shoigu! Gerasimov!" << (iter==NULL) << std::endl;
    tesseract::PageIteratorLevel level = tesseract::RIL_WORD;
    std::cout << "Shoigu! Gerasimov!" << (iter==NULL) << std::endl;
    // // CGEventRef event = CGEventCreate(NULL);
    // // CGPoint cursorPos = CGEventGetLocation(event);
    // // CFRelease(event);
    DetectedWords recWords = DetectedWords();
    int a = 0;

    if (iter != NULL) {
        do {

            const char* word = iter->GetUTF8Text(level);
            float confidence = iter->Confidence(level);
            if (confidence > 0.6) {

            int x1, y1, x2, y2;
            iter->BoundingBox(level, &x1, &y1, &x2, &y2);
            recWords.AddWord(word, confidence, x1,x2,y1,y2);
            std::cout << "Length: " << recWords.recognizedWords.size() << std::endl; 
            std::cout << "Word: " << recWords.recognizedWords[a].word << std::endl; 
            // std::cout << x1 << " " << y1 << " " << x2 << " " << word << std::endl;    
    // Print the coordinates
            // std::cout << "Shoigu! Gerasimov!" << x1 << std::endl;
            // Draw a rectangle around the recognized word
            // std::cout << "Recognized word: " << word << " (confidence: " << confidence << ")" << std::endl;
            }
            a++;
            delete[] word;
        } while (iter->Next(level));
    }
    // cv::imshow("res", screenshot);
    // Clean up
    delete iter;
    api.End();
    // cv::waitKey(0);
    return 0;
}
